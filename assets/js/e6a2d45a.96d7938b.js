"use strict";(self.webpackChunkshuffle_docs=self.webpackChunkshuffle_docs||[]).push([[885],{1927:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>m,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"adding-removing","title":"Adding and removing items","description":"You can add and remove elements from shuffle after it has been created. This also works for infinite scrolling.","source":"@site/docs/adding-removing.md","sourceDirName":".","slug":"/adding-removing","permalink":"/Shuffle/docs/adding-removing","draft":false,"unlisted":false,"editUrl":"https://github.com/Vestride/Shuffle/tree/main/apps/website/docs/docs/adding-removing.md","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"tutorialSidebar","previous":{"title":"Events","permalink":"/Shuffle/docs/events"},"next":{"title":"API","permalink":"/Shuffle/docs/api"}}');var s=t(1085),o=t(1184);const r={sidebar_position:9},d="Adding and removing items",a={},l=[{value:"Adding elements",id:"adding-elements",level:2},{value:"Removing elements",id:"removing-elements",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"adding-and-removing-items",children:"Adding and removing items"})}),"\n",(0,s.jsx)(n.p,{children:"You can add and remove elements from shuffle after it has been created. This also works for infinite scrolling."}),"\n",(0,s.jsx)(n.h2,{id:"adding-elements",children:"Adding elements"}),"\n",(0,s.jsx)(n.p,{children:"Wherever you add the element in the DOM is where it will show up in the grid (assuming you\u2019re using the default sort-by-dom-order). With this in mind, you can append, prepend, or insert elements wherever you need to get them to show up in the right order."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"/**\n * Create some DOM elements, append them to the shuffle container, then notify\n * shuffle about the new items. You could also insert the HTML as a string.\n */\nonAppendBoxes() {\n  const elements = this._getArrayOfElementsToAdd();\n\n  elements.forEach((element) => {\n    this.shuffle.element.appendChild(element);\n  });\n\n  // Tell shuffle elements have been appended.\n  // It expects an array of elements as the parameter.\n  this.shuffle.add(elements);\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"removing-elements",children:"Removing elements"}),"\n",(0,s.jsxs)(n.p,{children:["Shuffle will animate the element away and then remove it from the DOM once it's finished. It will then emit the ",(0,s.jsx)(n.code,{children:"Shuffle.EventType.REMOVED"})," event with the array of elements in ",(0,s.jsx)(n.code,{children:"event.collection"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"this.shuffle.remove([element1, element2]);\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["Check out the ",(0,s.jsx)(n.a,{href:"https://codepen.io/Vestride/details/yLParZL",children:"adding and removing demo"}),"."]})})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},1184:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>d});var i=t(4041);const s={},o=i.createContext(s);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);