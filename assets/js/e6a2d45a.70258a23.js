"use strict";(globalThis.webpackChunkshuffle_docs=globalThis.webpackChunkshuffle_docs||[]).push([[885],{5707:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>m,frontMatter:()=>o,metadata:()=>d,toc:()=>l});var i=t(1085),s=t(1184);const o={sidebar_position:9},r="Adding and removing items",d={id:"adding-removing",title:"Adding and removing items",description:"You can add and remove elements from shuffle after it has been created. This also works for infinite scrolling.",source:"@site/docs/adding-removing.md",sourceDirName:".",slug:"/adding-removing",permalink:"/Shuffle/docs/adding-removing",draft:!1,unlisted:!1,editUrl:"https://github.com/Vestride/Shuffle/tree/main/apps/website/docs/docs/adding-removing.md",tags:[],version:"current",sidebarPosition:9,frontMatter:{sidebar_position:9},sidebar:"tutorialSidebar",previous:{title:"Events",permalink:"/Shuffle/docs/events"},next:{title:"API",permalink:"/Shuffle/docs/api"}},a={},l=[{value:"Adding elements",id:"adding-elements",level:2},{value:"Removing elements",id:"removing-elements",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"adding-and-removing-items",children:"Adding and removing items"}),"\n",(0,i.jsx)(n.p,{children:"You can add and remove elements from shuffle after it has been created. This also works for infinite scrolling."}),"\n",(0,i.jsx)(n.h2,{id:"adding-elements",children:"Adding elements"}),"\n",(0,i.jsx)(n.p,{children:"Wherever you add the element in the DOM is where it will show up in the grid (assuming you\u2019re using the default sort-by-dom-order). With this in mind, you can append, prepend, or insert elements wherever you need to get them to show up in the right order."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"/**\n * Create some DOM elements, append them to the shuffle container, then notify\n * shuffle about the new items. You could also insert the HTML as a string.\n */\nonAppendBoxes() {\n  const elements = this._getArrayOfElementsToAdd();\n\n  elements.forEach((element) => {\n    this.shuffle.element.appendChild(element);\n  });\n\n  // Tell shuffle elements have been appended.\n  // It expects an array of elements as the parameter.\n  this.shuffle.add(elements);\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"removing-elements",children:"Removing elements"}),"\n",(0,i.jsxs)(n.p,{children:["Shuffle will animate the element away and then remove it from the DOM once it's finished. It will then emit the ",(0,i.jsx)(n.code,{children:"Shuffle.EventType.REMOVED"})," event with the array of elements in ",(0,i.jsx)(n.code,{children:"event.collection"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"this.shuffle.remove([element1, element2]);\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Check out the ",(0,i.jsx)(n.a,{href:"https://codepen.io/Vestride/details/yLParZL",children:"adding and removing demo"}),"."]})})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},1184:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>d});var i=t(4041);const s={},o=i.createContext(s);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);